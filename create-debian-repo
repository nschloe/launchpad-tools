#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
import argparse
import git
import os
import shutil
import subprocess
import tempfile


def update_patches(directory):
    '''debuild's patch apply doesn't allow fuzz, but fuzz is often what happens
    when applying a Debian patch to the master branch. `patch` itself is more
    robust, so use that here to update the Debian patches.
    '''
    debian_dir = os.path.join(directory, 'debian')
    if os.path.isfile(os.path.join(debian_dir, 'patches', 'ubuntu.series')):
        series = os.path.join(debian_dir, 'patches', 'ubuntu.series')
    elif os.path.isfile(os.path.join(debian_dir, 'patches', 'series')):
        series = os.path.join(debian_dir, 'patches', 'series')
    else:
        return

    with open(series, 'r') as f:
        content = f.readlines()

    if content:
        try:
            repo = git.Repo(directory)
        except git.exc.InvalidGitRepositoryError:
            raise RuntimeError('Directory %s is not Git-managed.' % directory)

        repo.git.checkout('.')

        tmp_dir = tempfile.mkdtemp()
        filenames = []
        for line in content:
            filename = line.strip()
            if filename[0] == '#':
                # skip commented-out lines
                continue

            repo.git.checkout('.')
            # apply the patch
            patch_path = os.path.join(debian_dir, 'patches', filename)
            try:
                # Don't use git.apply here: It doesn't understand fuzz.
                os.chdir(directory)
                subprocess.check_call(
                    'patch -f -p 1 < %s' % patch_path,
                    shell=True
                    )
            except subprocess.CalledProcessError:
                # Patch cannot be applied properly. That happens, just pass on
                # this one then.
                print('\n  Patch NOT properly applied. Skipping.\n')
                continue

            filenames.append(filename)
            # write diff to temporary file
            with open(os.path.join(tmp_dir, filename), 'w') as f:
                f.write(repo.git.diff())
                f.write('\n')

        # move the files back over to debian/patches
        repo.git.checkout('.')
        for filename in filenames:
            shutil.move(
                    os.path.join(tmp_dir, filename),
                    os.path.join(debian_dir, 'patches', filename)
                    )

        # shutil.rmtree(tmp_dir)

    return


def _parse_cmd_arguments():
    parser = argparse.ArgumentParser(
            description='Update patches builds to launchpad.'
            )
    parser.add_argument(
            '--orig', '-r',
            type=str,
            required=True,
            help='orig source'
            )
    parser.add_argument(
            '--debian', '-d',
            type=str,
            help='debian source'
            )
    parser.add_argument(
            '--out', '-o',
            type=str,
            required=True,
            help='output directory'
            )
    return parser.parse_args()


def _copytree(source, dest):
    '''Workaround until Python 3.5, fixing
    <https://bugs.python.org/issue21697>, is available.
    '''
    import subprocess
    command = 'cp -r %s %s' % (source, dest)
    process = subprocess.Popen(
            command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            close_fds=True
            )
    process.stdout.read()[:-1]
    ret = process.wait()

    if ret != 0:
        import sys
        sys.exit( "\nERROR: The command \n\n%s\n\nreturned a nonzero " \
                  "exit status. The error message is \n\n%s\n\n" \
                  "Abort.\n" % \
                  ( command, process.stderr.read()[:-1] )
                )

    return


def find_all_dirs(name, path):
    # From http://stackoverflow.com/a/1724723/353337
    result = []
    for root, dirs, files in os.walk(path):
        if name in dirs:
            result.append(os.path.join(root, name))
    return result


def find_all_files(name, path):
    # From http://stackoverflow.com/a/1724723/353337
    result = []
    for root, dirs, files in os.walk(path):
        if name in files:
            result.append(os.path.join(root, name))
    return result


def sanitize_directory_name(string):
    return string \
        .replace('\n', '-') \
        .replace(' ', '-') \
        .replace(':', '-') \
        .replace('/', '-')


def get_dir_from_git(git_url):
    repo_dir = os.path.join('/tmp', sanitize_directory_name(git_url))
    if os.path.isdir(repo_dir):
        repo = git.Repo(repo_dir)
        origin = repo.remotes.origin
        origin.pull()
    else:
        git.Repo.clone_from(git_url, repo_dir)

    return repo_dir


def get_dir_from_svn(url):
    repo_dir = os.path.join('/tmp', sanitize_directory_name(url))
    if os.path.isdir(repo_dir):
        os.chdir(repo_dir)
        # Call `svn info` first since `svn up` returns exit code 0 even if the
        # directory is not a repository.
        subprocess.check_call(
                'svn info',
                shell=True
                )
        subprocess.check_call(
                'svn up',
                shell=True
                )
    else:
        subprocess.check_call(
                'svn checkout %s %s' % (url, repo_dir),
                shell=True
                )

    return repo_dir


def get_dir_from_dsc(url):
    repo_dir = os.path.join('/tmp', sanitize_directory_name(url))
    if os.path.isdir(repo_dir):
        shutil.rmtree(repo_dir)
    os.mkdir(repo_dir)
    os.chdir(repo_dir)
    subprocess.check_call(
            'dget %s' % (url),
            shell=True
            )
    # Find the appropriate subdirectory
    for item in os.listdir(repo_dir):
        if os.path.isdir(item):
            return item


def get_dir(source):
    try:
        return get_dir_from_git(source)
    except git.exc.GitCommandError:
        pass
    except git.exc.InvalidGitRepositoryError:
        pass

    try:
        return get_dir_from_svn(source)
    except subprocess.CalledProcessError:
        pass

    try:
        return get_dir_from_dsc(source)
    except subprocess.CalledProcessError:
        pass

    raise RuntimeError('Couldn\'t handle source %s. Abort.' % source)


def create_repo(orig, debian, out):
    orig_dir = get_dir(orig)
    _copytree(os.path.join(orig_dir, '*'), out)

    if debian:
        assert not os.path.isdir(os.path.join(out, 'debian'))
        debian_dir = get_dir(debian)
        _copytree(os.path.join(debian_dir, 'debian'), out)

    assert os.path.isdir(os.path.join(out, 'debian'))

    # Remove git-related entities to ensure a smooth creation of the repo below
    try:
        for dot_git in find_all_dirs('.git', out):
            shutil.rmtree(dot_git)
        for dot_gitignore in find_all_files('.gitignore', out):
            os.remove(dot_gitignore)
    except FileNotFoundError:
        pass

    repo = git.Repo.init(out)
    repo.index.add('*')
    repo.index.commit('import orig, debian')

    update_patches(out)
    repo.git.add(update=True)
    repo.index.commit('updated patches')

    return


if __name__ == '__main__':
    args = _parse_cmd_arguments()
    create_repo(args.orig, args.debian, args.out)
